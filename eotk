#!/bin/sh
# Enterprise Onion Toolkit

cd `dirname $0` || exit 1

export EOTK_HOME=`pwd` # expected by tools

# set project directory; this path is hard-replicated elsewhere
project_dir=$EOTK_HOME/projects.d

# set path
export PATH=$EOTK_HOME/opt.d:$EOTK_HOME/lib.d:$PATH

# meta
prog=`basename $0`
version=1.1alpha

# print a formatted message to stdout
Print() {
    echo "$prog:" "$@"
}

# print a formatted message to stderr
Warn() {
    Print "$@" 1>&2
}

# essentially the projects.d folder is a little database
ListProjects() {
    (
        cd $project_dir || exit 1
        for d in *.d/ ; do
            echo `basename $d .d`
        done
    )
}

# what are the names of the remote workers?
CloudHosts() { # fake this up for the moment
    # echo "localhost" # this will be magic
    echo "rig1"
    echo "rig2"
    echo "rig3"
    echo "rig4"
    echo "rig5"
    echo "rig6"
}

# mirror eotk directory to remote
Push() {
    for host in `CloudHosts` ; do
        test "$host" = "localhost" && continue # skip self
        echo :::: host: $host :::: # NOTE: PURGE delete-excluded
        rsync \
            -av \
            --delete \
            --delete-excluded \
            --exclude="*~" \
            --exclude=".git/" \
            --exclude="configure*.log" \
            --exclude="hostname" \
            --exclude="onion_service_non_anonymous" \
            --exclude="private_key" \
            --exclude="secrets.d/" \
            ${EOTK_HOME}/ \
            $host:${EOTK_HOME}/
    done
}

# pull remote back for log review, backup, etc
Pull() {
    for host in `CloudHosts` ; do
        test "$host" = "localhost" && continue # skip self
        echo :::: host: $host ::::
    done
}

RemoteAction() {
    for host in `CloudHosts` ; do
        test "$host" = "localhost" && continue # skip self
        echo :::: host: $host ::::
        ssh "$host" "${EOTK_HOME}/eotk $*"
    done
}

# run a command in the context of the local projects directory
LocalAction() {
    action=$1
    shift

    verbose=false

    if [ "x$1" = "x" ] ; then
        Print error: missing project name, try: $prog projects for a list, or -a for all
        return 1
    elif [ "x$1" = "x-a" ] ; then
        projects=`ListProjects`
        verbose=true
    else
        projects="$*"
    fi

    for project in $projects ; do
        $verbose && echo :::: project: $project ::::
        sh $project_dir/$project.d/$action.sh
    done
}

# implement kludge to insert freshly-generated onions into a "*.tconf"
# template-configuration, so people don't have to type so much...
Populate() {
    if [ -t 0 ] ; then # if stdin is a terminal, provide diags
        dots=true
    else
        dots=false
    fi

    cat "$@" |
        while read line ; do
            case "$line" in
                *%NEW_ONION%*) # legacy / shorter / more common
                    onion=secrets.d/`$EOTK_HOME/eotk genkey`
                    echo "$line" | sed -e "s!%NEW_ONION%!$onion!"
                    ;;
                *%NEW_HARD_ONION%*)
                    onion=secrets.d/`$EOTK_HOME/eotk genkey`
                    echo "$line" | sed -e "s!%NEW_HARD_ONION%!$onion!"
                    ;;
                *%NEW_SOFT_ONION%*)
                    onion=`$EOTK_HOME/eotk genkey`
                    onion=`basename $onion .key`
                    echo "$line" | sed -e "s!%NEW_SOFT_ONION%!$onion!"
                    ;;
                *)
                    echo "$line"
                    ;;
            esac

            if $dots ; then
                echo ".\c" >/dev/tty
            fi
        done

    if $dots ; then
        echo "" >/dev/tty
    fi
}

# get a config file and re/populate the projects directory with it
Configure() {
    log=configure$$.log

    for file in "$@" ; do
        echo :::: file: $file ::::

        case "$file" in
            *.conf)
                : happy bunnies
                ;;

            *.tconf)
                file2=`basename $file .tconf`.conf
                if [ -s $file2 ] ; then
                    Print info: $file: using existing $file2
                else
                    Print info: $file: populating $file2 with onions, please be patient...
                    Populate $file >$file2
                fi
                file="$file2"
                ;;

            *)
                Print error: bad config file suffix, was expecting: .conf, .tconf
                exit 1
                ;;
        esac

        if ! $EOTK_HOME/lib.d/do-configure.pl "$file" ; then
            Print error: failure processing $file: see $log
            exit 1
        fi
    done 2>$log

    Print info: done, logfile: $log
}

# argument 'parser' - ha!

cmd="$1"

shift # we may need the remaining args

case "$cmd" in
    version)
        echo $prog: $version $EOTK_HOME
        if [ -f .gitignore ] ; then
            git show -s --oneline
        fi
        ;;

    projects|proj)
        ListProjects
        ;;

    populate|pop)
        Populate "$@"
        ;;

    configure|config|conf)
        Configure "$@"
        ;;

    start) # project, or "-a"
        LocalAction start "$@"
        ;;

    stop) # project, or "-a"
        LocalAction stop "$@"
        ;;

    bounce|restart|reload) # project, or "-a"
        LocalAction bounce "$@"
        ;;

    nxreload) # project, or "-a"
        LocalAction nxreload "$@"
        ;;

    debugon) # project, or "-a"
        LocalAction debugon "$@"
        ;;

    debugoff) # project, or "-a"
        LocalAction debugoff "$@"
        ;;

    harvest|onions) # project, or "-a"
        LocalAction harvest "$@"
        ;;

    status) # project, or "-a"
        LocalAction status "$@"
        ;;

    maps|map) # project, or "-a"
        LocalAction maps "$@"
        ;;

    ps)
        ps auxww | grep /eotk/
        ;;

    genkey|gen)
        secrets=secrets.d
        test -d $secrets || mkdir $secrets || exit 1
        (
            cd $secrets
            generate-onion-key.sh
        )
        ;;

    delete) # project, or "-a"
        echo $prog: delete is tbd
        ;;

    push)
        Push
        ;;

    pull)
        Pull
        ;;

    remote)
        RemoteAction "$@"
        ;;

    *)
        Print usage: see README.md for documentation
        exit 1
        ;;
esac

exit 0
